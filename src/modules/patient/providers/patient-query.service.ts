import { QueryService, mergeFilter } from '@nestjs-query/core';
import { TypeOrmQueryService } from '@nestjs-query/query-typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Patient, PatientReport } from '../models/patient.model';
import { CreatePatientInput } from '../dto/create-patient.input';
import { User } from 'src/modules/user/models/user.model';
import { PatientAuthorizer } from '../authorizers/patient.authorizer';
import { Inject, NotFoundException } from '@nestjs/common';
import { QuestionnaireAssessmentService } from 'src/modules/questionnaire/services/questionnaire-assessment.service';
import { QuestionnaireAssessment } from 'src/modules/questionnaire/models/questionnaire-assessment.schema';
import { IAnswerMap } from 'src/modules/questionnaire/models/answer.schema';
import {
    AnsweredQuestions,
    IQuestionGroup,
} from 'src/modules/questionnaire/models/questionnaire.schema';
import { AssessmentResponse } from 'src/modules/assessment/models/assessment.model';
import { QuestionnaireScriptService } from 'src/modules/questionnaire/services/questionnaire-script.service';

@QueryService(Patient)
export class PatientQueryService extends TypeOrmQueryService<Patient> {
    @Inject(QuestionnaireAssessmentService)
    questionnaireAssessmentService: QuestionnaireAssessmentService;
    @Inject(QuestionnaireScriptService)
    questionnaireScriptService: QuestionnaireScriptService;
    constructor(@InjectRepository(Patient) repo: Repository<Patient>) {
        // pass the use soft delete option to the service.
        super(repo, { useSoftDelete: true });
    }

    /**
     * Get patient if authorized. Throws exception if Not Found
     *
     * @param currentUser
     * @param patientId
     * @returns
     *
     * @throws NotFoundException
     */
    async getOnePatient(currentUser: User, patientId: number) {
        const authorizeFilter = await PatientAuthorizer.authorizePatient(
            currentUser?.id,
        );

        const combinedFilter = mergeFilter(
            { id: { eq: patientId } },
            authorizeFilter,
        );

        const patients = await super.query({
            paging: { limit: 1 },
            filter: combinedFilter,
        });

        const patient = patients?.[0];

        if (!patient) {
            throw new NotFoundException();
        }

        return patient;
    }

    async createOne(input: CreatePatientInput): Promise<Patient> {
        const patient = await super.createOne(input);

        if (input.departmentIds) {
            await super.addRelations(
                'departments',
                patient.id,
                input.departmentIds,
            );
        }

        return patient;
    }

    async createMany(input: CreatePatientInput[]): Promise<Patient[]> {
        const patients = await super.createMany(input);

        let counter = 0;

        for (const patient of patients) {
            if (input[counter++].departmentIds) {
                await super.addRelations(
                    'departments',
                    patient.id,
                    input[counter++].departmentIds,
                );
            }
        }

        return patients;
    }

    async getQuestionnaireReport(
        id: number,
        status?: string,
        questionnaireId?: string,
    ): Promise<PatientReport> {
        const condition = status ? `assessments.status = '${status}'` : 'true';
        const patient = await this.repo.findOne({
            join: {
                alias: 'patient',
                leftJoinAndSelect: { assessments: 'patient.assessments' },
            },
            where: qb => {
                qb.where({
                    id,
                }).andWhere(condition);
            },
        });

        const queries = [] as Promise<QuestionnaireAssessment>[];
        const answeredQuestionnaires = [];
        const answers = [];
        let questionnaireScripts = [];

        for (const assessment of patient.assessments) {
            queries.push(
                this.questionnaireAssessmentService.getById(
                    assessment.questionnaireAssessmentId,
                ),
            );
        }
        const questionnaireAssessment = await Promise.all(queries);
        for (const assessment of questionnaireAssessment) {
            assessment.questionnaires.forEach(entry => {
                if (
                    (questionnaireId &&
                        questionnaireId == entry._id.toString()) ||
                    !questionnaireId
                ) {
                    answeredQuestionnaires.push({
                        ...entry,
                        assessmentId: assessment._id.toString(),
                        ...entry._doc,
                    });
                    answers.push(assessment.answers);
                }
            });
        }

        for (let i = 0; i < answeredQuestionnaires.length; i++) {
            const answeredQuestionnaire = answeredQuestionnaires[i];

            const questionnaireName = answeredQuestionnaire.abbreviation;
            const questionnaireLanguage = answeredQuestionnaire.language;

            const [
                questionnaireScriptsData,
            ] = await this.questionnaireScriptService.getQuestionnaireScriptsById(
                answeredQuestionnaire?._doc._id.toString(),
            );

            if (questionnaireScriptsData) {
                questionnaireScripts = [
                    ...questionnaireScripts,
                    {
                        ...questionnaireScriptsData,
                        questionnaireName,
                        questionnaireLanguage,
                    },
                ];
            }

            answeredQuestionnaire.abbreviation =
                answeredQuestionnaire?._doc?.questionnaire?.abbreviation;
            answeredQuestionnaire.questionnaireFullName =
                answeredQuestionnaire?._doc?.name;
            answeredQuestionnaire.language =
                answeredQuestionnaire._doc.questionnaire?.language;
            answeredQuestionnaire.name =
                answeredQuestionnaire?._doc?.questionnaire?.abbreviation;

            const answeredQuestionsMap = PatientQueryService.mapAnsweredQuestions(
                answers[i],
            );
            const questionGroups = answeredQuestionnaire._doc?.questionGroups?.flat();
            const questions = PatientQueryService.matchQuestionsToAnswers(
                questionGroups ?? [],
                answeredQuestionsMap,
            );
            answeredQuestionnaire.questions = questions;
        }
        const assessmentResponse = [] as AssessmentResponse[];

        for (const assessment of patient.assessments) {
            assessmentResponse.push({
                ...assessment,
                assessmentId: assessment.questionnaireAssessmentId,
            } as AssessmentResponse);
        }

        console.log(questionnaireScripts);

        return {
            patient,
            answeredQuestionnaires,
            questionnaireScripts,
            assessments: assessmentResponse,
        } as PatientReport;
    }

    private static mapAnsweredQuestions(answers: AnsweredQuestions[]) {
        const map = {} as IAnswerMap;
        for (const answer of answers) {
            answer.combinedDate = null;
            map[answer.question.toString()] = { ...answer['_doc'] };
            map[answer.question.toString()][
                'questionId'
            ] = answer.question.toString();
            if (answer.dateValue && answer.textValue) {
                const [hours, minutes] = answer.textValue.split(':');
                map[answer.question.toString()]['combinedDate'] = new Date(
                    answer.dateValue.setUTCHours(+hours, +minutes, 0, 0),
                );
            }
        }
        return map;
    }

    private static matchQuestionsToAnswers(
        questionGroups: IQuestionGroup[],
        answeredQuestionsMap: IAnswerMap,
    ) {
        let results = [];

        for (const questionGroup of questionGroups) {
            const questions = questionGroup.questions.map(question => {
                const { type, name, label, required, choices, hint } = question;
                return {
                    type,
                    variable: name,
                    label,
                    required,
                    choices,
                    hint,
                    questionGrouplabel: questionGroup.label,
                    answer: answeredQuestionsMap[question._id.toString()],
                };
            });

            results = results.concat(questions);
        }
        return results;
    }
}
